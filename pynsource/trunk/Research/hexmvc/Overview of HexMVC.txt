Overview of HexMVC
==================

Misc notes.


AIM
---
Replacing hard to follow pure mvc home-grown eventing with simple multicast
calling of methods on objects. All objects/subsystems are injected hexagonal
style, and adhere to abstract interfaces for swappability.



On The Role of App

------------------

App has job of housing the domain logic and app logic and thus the controller/commands.
App also has job of wiring the ring adapters together as it knows the relationship of them all to each other.
App sometimes mediates - calls come in and app sends them out again.
App sometimes steps out of the way, wires up the ring adapters to talk to each other.

Instantiation should be outside the app.  Theoretically inject different ring adapters into the app
and the app will still work.

Injection single vs. multicast - a neat symmetry.
---------------------------------------------------
Inject a single object to a var (destination expects an interface to be adhered to, doesn't care about the object)

OR

Inject append to a multicast var (destination expects an interface to be adhered to, doesn't care about the object). Calls on the object's method are the same as if it was a single object.  The multicasting is hidden.  But same philosophy.  Thus we dispense with eventing and anything complex.  Its all just function calls on objects, where the object is anything that satisfies an interface/convention.

Renamings of pureMvc terms to "Adapter"
---------------------------------------

PureMvc uses the term one or more "mediators" in front of gui plumbing - all sitting behind the term "View"
PureMvc uses the term one or more "proxies" in front of model plumbing - all sitting behind the term "Model"
PureMvc talks about many "commands" objects which all sit behind the term "Controller"
The Application "facade" is the centre.

The problem with these terms are that is debatable that these things are really proxies and mediators etc.  I rename them Adapters.
The other problem in puremvc is that additional plug in parts of the architecture (which is not catered for anyway) need pattern names too, so by using the generic name Adapter we can have infinite numbers of Adapters composing a system.

Plus Adapters are more conducive to the idea of interfaces.  Adapters offer the same interface, whilst the behind the scenes implementation changes - this is the very essence of what an Adapter is.  And its the very essence of what an interface is, and thus the injecting of adapters that conform to some interface is a good thing to do.  And remember by having multicast variables pointing to multiple adapters, we get a simple "event"-ing framework - for free.

Adapters can be wrapping or inheriting - that's in the design pattern book.
My wx pure minimalist gui adapter is an example of a wrapping (compositional) adapter.
My wx architecture 3 gui adapter is an example of an inheritance based adapter.


EARLY TALK SUMMARY
------------------
I have a talk entitled "HexMVC" brewing which is a simplified blend of the Hexagonal architecture, PureMVC and dependency injection.  Not sure I can have it ready for February but am keen to present it to the group soon.

I have an implementation of HexMVC in Python which proves the ideas work (so far!), allowing developers to "program to interfaces/abstractions" and plug and play different implementations within an MVC architecture.  The ideas aren't new but what HexMVC aims at is a useful blend of patterns and idioms - resulting in a simple architectural pattern that anybody can build a complex app with.  And there is no 'framework' code needed to get started, you just start coding with any language, with the pattern "in your head".

Here is my bootstrap code of my demo app:

# HEXMVC BOOT WIRING v3 - model is separate

from hexapp import App
from hexserver import Server1
from hexmvcgui import MyWxApp
import wx

# Create Gui
wxapp = MyWxApp(redirect=False)
gui = wxapp.myframe  # arguably too wx based to be a true adapter, but as long
                     # as we call nothing wx specific, it acts as an adapter ok.
# Create Server
server = Server1(host='localhost', port=8081)

# Create Persistence
# Create Model - SIMPLE
from hexmodel_simple import Model
from hexpersistence import PersistenceMock2
persistence = PersistenceMock2()
model = Model(persistence)
    
# Create Core Hexagon App and inject adapters
app = App(model, server, gui)
wx.CallAfter(app.Boot)

# Start Gui
wxapp.MainLoop()



# generate java

from gen_asciiart import PySourceAsText
import os, glob
from keywords import javakeywords

class PySourceAsJava(PySourceAsText):
    def __init__(self, outdir=None):
        PySourceAsText.__init__(self)
        self.outdir = outdir
        self.fp = None

    def _DumpClassFooter(self):
        self.result +=  "}\n"

        if self.fp:
            self.fp.write(self.result)
            self.fp.close()
            self.fp = None
            self.result = ''

    def _DumpModuleMethods(self):
        self.result += '/*\n'
        PySourceAsText._DumpModuleMethods(self)
        self.result += '*/\n'

    def _OpenNextFile(self):
        filepath = "%s\\%s.java" % (self.outdir, self.aclass)
        self.fp = open(filepath, 'w')


    def _NiceNameToPreventCompilerErrors(self, attrname):
        """
        Prevent compiler errors on the java side by checking and modifying attribute name
        """
        # only emit the rhs of a multi part name e.g. undo.UndoItem will appear only as UndoItem
        if attrname.find('.') <> -1:
            attrname = attrname.split('.')[-1] # take the last
        # Prevent compiler errors on the java side by avoiding the generating of java keywords as attribute names
        if attrname in javakeywords:
            attrname = '_' + attrname
        return attrname

    def _DumpAttribute(self, attrobj):
        compositescreated = self._GetCompositeCreatedClassesFor(attrobj.attrname)
        if compositescreated:
            compositecreated = compositescreated[0]
        else:
            compositecreated = None

        # Extra processing on the attribute name, to avoid java compiler errors
        attrname = self._NiceNameToPreventCompilerErrors(attrobj.attrname)

        if compositecreated and self.embedcompositeswithattributelist:
            self.result +=  "    public %s %s %s = new %s();\n" % (self.staticmessage, compositecreated, attrname, compositecreated)
        else:
##            self.result +=  "    public %s void %s;\n" % (self.staticmessage, attrobj.attrname)
##            self.result +=  "    public %s int %s;\n" % (self.staticmessage, attrname)
            self.result +=  "    public %s variant %s;\n" % (self.staticmessage, attrname)

        """
        import java.util.Vector;

        private java.util.Vector lnkClass4;

        private Vector lnkClass4;
        """

    def _DumpCompositeExtraFooter(self):
        pass

    def _DumpClassNameAndGeneralisations(self):
        if self.verbose:
            print '  Generating Java class', self.aclass
        self._OpenNextFile()

        self.result += "// Generated by PyNSource http://www.andypatterns.com/index.php/products/pynsource/ \n\n"

##        self.result +=  "import javax.swing.Icon;     // Not needed, just testing pyNSource's ability to generate import statements.\n\n"    # NEW package support!

        self.result +=  'public class %s ' % self.aclass
        if self.classentry.classesinheritsfrom:
            self.result +=  'extends %s ' % self._NiceNameToPreventCompilerErrors(self.classentry.classesinheritsfrom[0])
        self.result +=  '{\n'

    def _DumpMethods(self):
        for adef in self.classentry.defs:
            self.result +=  "    public void %s() {\n    }\n" % adef

    def _Line(self):
        pass


class PythonToJava:
    def __init__(self, directories, treatmoduleasclass=0, verbose=0):
        self.directories = directories
        self.optionModuleAsClass = treatmoduleasclass
        self.verbose = verbose

    def _GenerateAuxilliaryClasses(self):
        classestocreate = ('variant', 'unittest', 'list', 'object', 'dict')  # should add more classes and add them to a jar file to avoid namespace pollution.
        for aclass in classestocreate:
            fp = open(os.path.join(self.outpath, aclass+'.java'), 'w')
            fp.write(self.GenerateSourceFileForAuxClass(aclass))
            fp.close()

    def GenerateSourceFileForAuxClass(self, aclass):
       return '\npublic class %s {\n}\n'%aclass

    def ExportTo(self, outpath):
        self.outpath = outpath

        self._GenerateAuxilliaryClasses()

        for directory in self.directories:
            if '*' in directory or '.' in directory:
                filepath = directory
            else:
                filepath = os.path.join(directory, "*.py")
            if self.verbose:
                print 'Processing directory', filepath
            globbed = glob.glob(filepath)
            #print 'Java globbed is', globbed
            for f in globbed:
                self._Process(f)

    def _Process(self, filepath):
        if self.verbose:
            padding = ' '
        else:
            padding = ''
        thefile = os.path.basename(filepath)
        if thefile[0] == '_':
            print '  ', 'Skipped', thefile, 'cos begins with underscore.'
            return
        print '%sProcessing %s...'%(padding, thefile)
        p = self._CreateParser()
        p.Parse(filepath)
        str(p)  # triggers the output.

    def _CreateParser(self):
        p = PySourceAsJava(self.outpath)
        p.optionModuleAsClass = self.optionModuleAsClass
        p.verbose = self.verbose
        return p

